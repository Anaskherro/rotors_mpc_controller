#!/usr/bin/env python3

"""ROS front-end for the acados-based NMPC controller."""

from __future__ import annotations

import math
import threading
from typing import Optional

import numpy as np
import rospy
from dynamic_reconfigure.server import Server
from geometry_msgs.msg import PoseStamped
from mav_msgs.msg import Actuators
from nav_msgs.msg import Odometry
from std_srvs.srv import SetBool, SetBoolRequest, SetBoolResponse

from rotors_mpc_controller import (PositionNMPC, ReferenceGenerator,
                                   apply_dynamic_configuration,
                                   load_params)
from rotors_mpc_controller.cfg import RotorsMPCConfig
from rotors_mpc_controller.trajectory import generate_loop_reference



def quaternion_to_euler(qx: float, qy: float, qz: float, qw: float) -> tuple[float, float, float]:
    norm = math.sqrt(qx * qx + qy * qy + qz * qz + qw * qw)
    if norm == 0.0:
        return 0.0, 0.0, 0.0
    qx /= norm
    qy /= norm
    qz /= norm
    qw /= norm

    sinr_cosp = 2.0 * (qw * qx + qy * qz)
    cosr_cosp = 1.0 - 2.0 * (qx * qx + qy * qy)
    roll = math.atan2(sinr_cosp, cosr_cosp)

    sinp = 2.0 * (qw * qy - qz * qx)
    pitch = math.copysign(math.pi / 2.0, sinp) if abs(sinp) >= 1.0 else math.asin(sinp)

    siny_cosp = 2.0 * (qw * qz + qx * qy)
    cosy_cosp = 1.0 - 2.0 * (qy * qy + qz * qz)
    yaw = math.atan2(siny_cosp, cosy_cosp)
    return roll, pitch, yaw


class MPCControllerNode:
    def __init__(self) -> None:
        self._params = load_params()
        self._controller = PositionNMPC(self._params)
        self._reference = ReferenceGenerator(self._params['reference'])
        self._reference.update_hover_thrust(self._controller.hover_thrust)
        self._trajectory_active = False
        self._trajectory_stage = 'idle'
        self._approach_target: dict | None = None
        self._pending_trajectory: dict | None = None
        self._init_reference_trajectory()
        self._topics = dict(self._params['topics'])
        node_cfg = self._params.get('node', {})
        self._rate_hz = float(node_cfg.get('rate', 50.0))
        self._log_interval = float(node_cfg.get('log_interval', 3.0))
        self._last_log_time = rospy.Time.now()
        self._controller_lock = threading.Lock()

        self._rotor_force_constant = self._controller.rotor_force_constant
        self._motor_min_speed, self._motor_max_speed = self._controller.motor_speed_limits

        self._state: Optional[dict] = None
        self._last_command = np.full(4, self._controller.hover_thrust, dtype=float)

        self._motor_pub = rospy.Publisher(self._topics['motor'], Actuators, queue_size=1)
        self._state_sub = rospy.Subscriber(self._topics['state'], Odometry,
                                           self._odom_cb, queue_size=1)
        self._reference_topic = self._topics.get('reference', '~setpoint')
        self._reference_sub = rospy.Subscriber(self._reference_topic, PoseStamped,
                                               self._reference_cb, queue_size=1)

        self._prepare_srv = rospy.Service('~prepare_trajectory', SetBool, self._prepare_service_cb)
        self._start_srv = rospy.Service('~start_trajectory', SetBool, self._start_service_cb)
        self._timer = rospy.Timer(rospy.Duration(1.0 / self._rate_hz), self._loop)
        self._reconfig_srv = Server(RotorsMPCConfig, self._reconfigure_cb)
        rospy.loginfo('mpc_controller_node: ready (dt=%.3f, horizon=%d)',
                      self._controller.dt, self._controller.horizon)

    def _reference_cb(self, msg: PoseStamped) -> None:
        position = np.array([msg.pose.position.x,
                             msg.pose.position.y,
                             msg.pose.position.z], dtype=float)
        yaw = self._yaw_from_quaternion(msg.pose.orientation.x,
                                        msg.pose.orientation.y,
                                        msg.pose.orientation.z,
                                        msg.pose.orientation.w)
        self._reference.set_target(position=position, yaw=yaw)

    def _odom_cb(self, msg: Odometry) -> None:
        pose = msg.pose.pose
        twist = msg.twist.twist

        px, py, pz = pose.position.x, pose.position.y, pose.position.z
        vx_body = np.array([twist.linear.x, twist.linear.y, twist.linear.z], dtype=float)

        roll, pitch, yaw = quaternion_to_euler(pose.orientation.x,
                                               pose.orientation.y,
                                               pose.orientation.z,
                                               pose.orientation.w)

        rot = self._rotation_matrix(roll, pitch, yaw)
        velocity_world = rot @ vx_body

        quaternion = np.array([pose.orientation.w,
                                pose.orientation.x,
                                pose.orientation.y,
                                pose.orientation.z], dtype=float)

        self._state = {
            'position': np.array([px, py, pz], dtype=float),
            'velocity': velocity_world,
            'quaternion': quaternion,
            'body_rates': np.array([twist.angular.x, twist.angular.y, twist.angular.z], dtype=float),
        }

    def _loop(self, _: rospy.TimerEvent) -> None:
        if self._state is None:
            return

        reference = self._reference.build_horizon(self._controller.horizon,
                                                  self._controller.dt)

        with self._controller_lock:
            thrust_cmd, status = self._controller.solve(self._state, reference)
        if status != 0:
            rospy.logwarn_throttle(1.0, 'mpc_controller_node: solver returned status %d', status)
            if self._last_command is not None:
                self._publish_command(self._last_command)
                self._maybe_log(reference, thrust_cmd, status)
            self._maybe_progress_trajectory()
            return
        self._publish_command(thrust_cmd)
        self._maybe_log(reference, thrust_cmd, status)
        self._maybe_progress_trajectory()

    @staticmethod
    def _yaw_from_quaternion(qx: float, qy: float, qz: float, qw: float) -> float:
        _, _, yaw = quaternion_to_euler(qx, qy, qz, qw)
        return yaw

    @staticmethod
    def _rotation_matrix(roll: float, pitch: float, yaw: float) -> np.ndarray:
        cr = math.cos(roll)
        sr = math.sin(roll)
        cp = math.cos(pitch)
        sp = math.sin(pitch)
        cy = math.cos(yaw)
        sy = math.sin(yaw)
        return np.array([
            [cp * cy, cy * sp * sr - sy * cr, cy * sp * cr + sy * sr],
            [cp * sy, sy * sp * sr + cy * cr, sy * sp * cr - cy * sr],
            [-sp, cp * sr, cp * cr],
        ], dtype=float)

    def _publish_command(self, thrust: np.ndarray) -> None:
        lbu, ubu = self._controller.input_bounds
        clipped = np.clip(np.asarray(thrust, dtype=float), lbu, ubu)
        speeds_sq = clipped / max(self._rotor_force_constant, 1e-9)
        speeds_sq = np.clip(speeds_sq, 0.0, self._motor_max_speed ** 2)
        speeds = np.sqrt(speeds_sq)
        speeds = np.clip(speeds, self._motor_min_speed, self._motor_max_speed)

        msg = Actuators()
        msg.header.stamp = rospy.Time.now()
        msg.angular_velocities = speeds.tolist()
        self._motor_pub.publish(msg)
        self._last_command = clipped

    def _maybe_log(self, reference: dict, thrust_cmd: np.ndarray, status: int) -> None:
        now = rospy.Time.now()
        if (now - self._last_log_time).to_sec() < self._log_interval:
            return
        self._last_log_time = now

        ref_pos = reference['positions'][0]
        ref_vel = reference['velocities'][0]
        ref_quat = reference['quaternions'][0]
        ref_rates = reference['body_rates'][0]
        ref_thrust = reference['thrusts'][0] if reference['thrusts'].size else np.zeros(4)

        rospy.loginfo(
            'MPC log: status=%d pos=%s vel=%s quat=%s ref_pos=%s ref_vel=%s ref_quat=%s ref_rates=%s ref_thrust=%s cmd=%s',
            status,
            np.array2string(self._state['position'], precision=3),
            np.array2string(self._state['velocity'], precision=3),
            np.array2string(self._state['quaternion'], precision=3),
            np.array2string(ref_pos, precision=3),
            np.array2string(ref_vel, precision=3),
            np.array2string(ref_quat, precision=3),
            np.array2string(ref_rates, precision=3),
            np.array2string(ref_thrust, precision=3),
            np.array2string(thrust_cmd, precision=3),
        )

    def _reconfigure_cb(self, config: RotorsMPCConfig, level: int) -> RotorsMPCConfig:
        with self._controller_lock:
            topics_cfg, reference_defaults, node_meta = apply_dynamic_configuration(self._params, config)

            rospy.loginfo('mpc_controller_node: rebuilding ACADOS solver...')
            new_controller = PositionNMPC(self._params)
            self._controller = new_controller

            regen_dt = new_controller.dt
            regen_horizon = new_controller.horizon
            regen_codegen = getattr(new_controller, 'codegen_path', 'n/a')
            self._rotor_force_constant = new_controller.rotor_force_constant
            self._motor_min_speed, self._motor_max_speed = new_controller.motor_speed_limits
            self._reference.update_hover_thrust(new_controller.hover_thrust)
            self._log_interval = node_meta['log_interval']

            self._reference.update_defaults(reference_defaults['position'],
                                            reference_defaults['velocity'],
                                            reference_defaults['yaw'],
                                            frame=reference_defaults['frame'])
            self._init_reference_trajectory()

            if topics_cfg != self._topics:
                if self._state_sub is not None:
                    self._state_sub.unregister()
                if self._reference_sub is not None:
                    self._reference_sub.unregister()
                if self._motor_pub is not None:
                    self._motor_pub.unregister()
                self._topics = dict(topics_cfg)
                self._motor_pub = rospy.Publisher(self._topics['motor'], Actuators, queue_size=1)
                self._state_sub = rospy.Subscriber(self._topics['state'], Odometry,
                                                   self._odom_cb, queue_size=1)
                self._reference_topic = self._topics['reference']
                self._reference_sub = rospy.Subscriber(self._reference_topic, PoseStamped,
                                                       self._reference_cb, queue_size=1)

            new_rate = node_meta['rate']
            if new_rate > 0.0 and not math.isclose(new_rate, self._rate_hz):
                self._rate_hz = new_rate
                if hasattr(self, '_timer') and self._timer is not None:
                    self._timer.shutdown()
                self._timer = rospy.Timer(rospy.Duration(1.0 / self._rate_hz), self._loop)

        rospy.loginfo('mpc_controller_node: regenerated ACADOS model (dt=%.3f, horizon=%d, codegen=%s)',
                      regen_dt, regen_horizon, regen_codegen)

        config.solver_horizon_steps = self._params['solver']['horizon_steps']
        config.solver_dt = self._params['solver']['dt']
        config.solver_position_weight_x = self._params['solver']['position_weight'][0]
        config.solver_position_weight_y = self._params['solver']['position_weight'][1]
        config.solver_position_weight_z = self._params['solver']['position_weight'][2]
        config.solver_velocity_weight_x = self._params['solver']['velocity_weight'][0]
        config.solver_velocity_weight_y = self._params['solver']['velocity_weight'][1]
        config.solver_velocity_weight_z = self._params['solver']['velocity_weight'][2]
        config.solver_quat_weight_w = self._params['solver']['quaternion_weight'][0]
        config.solver_quat_weight_x = self._params['solver']['quaternion_weight'][1]
        config.solver_quat_weight_y = self._params['solver']['quaternion_weight'][2]
        config.solver_quat_weight_z = self._params['solver']['quaternion_weight'][3]
        config.solver_rate_weight_x = self._params['solver']['rate_weight'][0]
        config.solver_rate_weight_y = self._params['solver']['rate_weight'][1]
        config.solver_rate_weight_z = self._params['solver']['rate_weight'][2]
        config.solver_control_weight_f1 = self._params['solver']['control_weight'][0]
        config.solver_control_weight_f2 = self._params['solver']['control_weight'][1]
        config.solver_control_weight_f3 = self._params['solver']['control_weight'][2]
        config.solver_control_weight_f4 = self._params['solver']['control_weight'][3]
        config.solver_terminal_weight_px = self._params['solver']['terminal_weight'][0]
        config.solver_terminal_weight_py = self._params['solver']['terminal_weight'][1]
        config.solver_terminal_weight_pz = self._params['solver']['terminal_weight'][2]
        config.solver_terminal_weight_vx = self._params['solver']['terminal_weight'][3]
        config.solver_terminal_weight_vy = self._params['solver']['terminal_weight'][4]
        config.solver_terminal_weight_vz = self._params['solver']['terminal_weight'][5]
        config.solver_terminal_weight_qw = self._params['solver']['terminal_weight'][6]
        config.solver_terminal_weight_qx = self._params['solver']['terminal_weight'][7]
        config.solver_terminal_weight_qy = self._params['solver']['terminal_weight'][8]
        config.solver_terminal_weight_qz = self._params['solver']['terminal_weight'][9]
        config.solver_terminal_weight_wx = self._params['solver']['terminal_weight'][10]
        config.solver_terminal_weight_wy = self._params['solver']['terminal_weight'][11]
        config.solver_terminal_weight_wz = self._params['solver']['terminal_weight'][12]
        config.solver_regularization = self._params['solver']['regularization']
        if hasattr(config, 'solver_iter_max'):
            config.solver_iter_max = self._params['solver']['iter_max']
        config.solver_codegen_directory = self._params['solver'].get('codegen_directory', '')

        config.vehicle_mass = self._params['vehicle']['mass']
        inertia = self._params['vehicle']['inertia']
        config.vehicle_inertia_xx = inertia[0]
        config.vehicle_inertia_xy = inertia[1]
        config.vehicle_inertia_xz = inertia[2]
        config.vehicle_inertia_yx = inertia[3]
        config.vehicle_inertia_yy = inertia[4]
        config.vehicle_inertia_yz = inertia[5]
        config.vehicle_inertia_zx = inertia[6]
        config.vehicle_inertia_zy = inertia[7]
        config.vehicle_inertia_zz = inertia[8]
        config.vehicle_arm_length = self._params['vehicle']['arm_length']
        config.vehicle_rotor_force_constant = self._params['vehicle']['rotor_force_constant']
        config.vehicle_rotor_moment_constant = self._params['vehicle']['rotor_moment_constant']
        config.vehicle_motor_min_speed = self._params['vehicle']['motor_min_speed']
        config.vehicle_motor_max_speed = self._params['vehicle']['motor_max_speed']
        drag = self._params['vehicle']['drag_coefficients']
        config.vehicle_drag_x = drag[0]
        config.vehicle_drag_y = drag[1]
        config.vehicle_drag_z = drag[2]

        config.controller_thrust_min = self._params['controller']['thrust_limits'][0]
        config.controller_thrust_max = self._params['controller']['thrust_limits'][1]

        config.world_gravity = self._params['world']['gravity']

        config.reference_frame = self._params['reference']['frame']
        config.reference_position_x = self._params['reference']['default_position'][0]
        config.reference_position_y = self._params['reference']['default_position'][1]
        config.reference_position_z = self._params['reference']['default_position'][2]
        config.reference_velocity_x = self._params['reference']['default_velocity'][0]
        config.reference_velocity_y = self._params['reference']['default_velocity'][1]
        config.reference_velocity_z = self._params['reference']['default_velocity'][2]
        config.reference_acceleration_x = self._params['reference']['default_acceleration'][0]
        config.reference_acceleration_y = self._params['reference']['default_acceleration'][1]
        config.reference_acceleration_z = self._params['reference']['default_acceleration'][2]
        config.reference_yaw = self._params['reference']['default_yaw']

        config.topic_state = self._topics['state']
        config.topic_motor = self._topics['motor']
        config.topic_reference = self._topics['reference']

        node_cfg = self._params['node']
        config.node_rate = self._rate_hz
        config.node_log_interval = self._log_interval

        return config

    def _init_reference_trajectory(self) -> None:
        ref_cfg = self._params.get('reference', {})
        traj_cfg = ref_cfg.get('trajectory')
        self._pending_trajectory = None

        if not traj_cfg or not traj_cfg.get('enabled', False):
            if self._trajectory_active:
                self._reference.clear_trajectory()
                self._trajectory_active = False
            self._trajectory_stage = 'idle'
            self._approach_target = None
            rospy.loginfo('mpc_controller_node: trajectory disabled; holding hover reference.')
            return

        dt = float(traj_cfg.get('dt', self._controller.dt))
        loop = bool(traj_cfg.get('loop', True))
        traj_type = str(traj_cfg.get('type', 'circle')).lower()
        start_tol = float(traj_cfg.get('start_position_tolerance', 0.15))

        trajectory_data: dict[str, np.ndarray] | None = None

        if traj_type == 'circle':
            trajectory_data = self._build_circular_trajectory(traj_cfg, dt)
        else:
            rospy.logwarn('mpc_controller_node: unsupported trajectory type %s', traj_type)
            return

        if trajectory_data is None:
            rospy.logwarn('mpc_controller_node: trajectory generation failed.')
            return

        positions = trajectory_data['positions']
        if positions.size == 0:
            rospy.logwarn('mpc_controller_node: trajectory generation returned empty positions.')
            return

        self._pending_trajectory = {
            'data': trajectory_data,
            'dt': float(trajectory_data.get('dt', dt)),
            'loop': loop,
            'type': traj_type,
            'start_tolerance': start_tol,
            'start_yaw': float(trajectory_data['yaws'][0]) if trajectory_data['yaws'].size else None,
            'positions': positions,
        }

        if self._pending_trajectory['start_yaw'] is None:
            if positions.shape[0] > 1:
                delta = positions[1] - positions[0]
                self._pending_trajectory['start_yaw'] = math.atan2(delta[1], delta[0])
            else:
                self._pending_trajectory['start_yaw'] = self._params['reference']['default_yaw']

        rospy.loginfo('mpc_controller_node: prepared %s trajectory with %d samples (dt=%.3f, loop=%s); call ~prepare_trajectory then ~start_trajectory.',
                      traj_type, positions.shape[0], self._pending_trajectory['dt'], 'true' if loop else 'false')

        if self._trajectory_stage != 'idle':
            rospy.loginfo('mpc_controller_node: trajectory updated; re-initiating preparation.')
            self._begin_trajectory_sequence()

    def _build_circular_trajectory(self, cfg: dict, dt: float) -> dict[str, np.ndarray]:
        return generate_loop_reference(self._controller, cfg, dt)

    def _activate_pending_trajectory(self) -> None:
        if self._pending_trajectory is None:
            rospy.logwarn('mpc_controller_node: no trajectory available to activate.')
            return

        traj = self._pending_trajectory
        data = traj['data']
        self._reference.set_trajectory(positions=data['positions'],
                                       dt=traj['dt'],
                                       velocities=data['velocities'],
                                       quaternions=data['quaternions'],
                                       body_rates=data['body_rates'],
                                       thrusts=data['thrusts'],
                                       yaw=data['yaws'],
                                       loop=traj['loop'])
        self._trajectory_active = True
        self._trajectory_stage = 'track'
        self._approach_target = None
        rospy.loginfo('mpc_controller_node: trajectory following enabled.')

    def _deactivate_trajectory(self) -> None:
        if self._trajectory_stage == 'idle' and not self._trajectory_active:
            rospy.loginfo('mpc_controller_node: trajectory already inactive.')
            return
        self._reference.clear_trajectory()
        if self._state is not None:
            yaw = self._yaw_from_quaternion(self._state['quaternion'][1],
                                            self._state['quaternion'][2],
                                            self._state['quaternion'][3],
                                            self._state['quaternion'][0])
            self._reference.set_target(position=self._state['position'],
                                       velocity=np.zeros(3),
                                       yaw=yaw)
        self._trajectory_active = False
        self._trajectory_stage = 'idle'
        self._approach_target = None
        rospy.loginfo('mpc_controller_node: trajectory control aborted; holding hover.')

    def _prepare_service_cb(self, req: SetBoolRequest) -> SetBoolResponse:
        if req.data:
            if self._pending_trajectory is None:
                return SetBoolResponse(success=False, message='No trajectory configured.')
            self._begin_trajectory_sequence()
            return SetBoolResponse(success=True, message='Approaching trajectory start.')

        self._deactivate_trajectory()
        return SetBoolResponse(success=True, message='Preparation cancelled.')

    def _start_service_cb(self, req: SetBoolRequest) -> SetBoolResponse:
        if not req.data:
            self._deactivate_trajectory()
            return SetBoolResponse(success=True, message='Trajectory stopped.')

        if self._pending_trajectory is None:
            return SetBoolResponse(success=False, message='No trajectory configured.')

        if self._trajectory_stage not in {'approach', 'ready'}:
            rospy.logwarn('mpc_controller_node: starting trajectory without preparation stage.')
        elif self._trajectory_stage == 'approach':
            rospy.logwarn('mpc_controller_node: starting trajectory before reaching start point.')

        self._activate_pending_trajectory()
        return SetBoolResponse(success=True, message='Trajectory tracking started.')

    def _begin_trajectory_sequence(self) -> None:
        if self._pending_trajectory is None:
            rospy.logwarn('mpc_controller_node: no trajectory configured for start sequence.')
            return

        data = self._pending_trajectory['data']
        start_pos = np.array(data['positions'][0], dtype=float)
        start_yaw = self._pending_trajectory.get('start_yaw')
        self._reference.clear_trajectory()
        kwargs: dict[str, object] = {
            'position': start_pos,
            'velocity': np.zeros(3),
        }
        if start_yaw is not None:
            kwargs['yaw'] = float(start_yaw)
        self._reference.set_target(**kwargs)
        self._trajectory_stage = 'approach'
        self._trajectory_active = False
        self._approach_target = {
            'position': start_pos,
            'yaw': float(start_yaw) if start_yaw is not None else None,
        }
        rospy.loginfo('mpc_controller_node: approaching trajectory start (tolerance=%.2f m).',
                      self._pending_trajectory.get('start_tolerance', 0.15))

    def _maybe_progress_trajectory(self) -> None:
        if self._trajectory_stage not in {'approach', 'ready'}:
            return
        if self._state is None or self._approach_target is None or self._pending_trajectory is None:
            return

        target_pos = self._approach_target['position']
        current_pos = self._state['position']
        distance = float(np.linalg.norm(current_pos - target_pos))
        tolerance = float(self._pending_trajectory.get('start_tolerance', 0.15))

        if distance > tolerance:
            if self._trajectory_stage == 'ready':
                rospy.loginfo('mpc_controller_node: drifted beyond start tolerance; continuing approach.')
            self._trajectory_stage = 'approach'
            return

        if self._trajectory_stage != 'ready':
            self._trajectory_stage = 'ready'
            rospy.loginfo('mpc_controller_node: start point reached; call ~start_trajectory to begin tracking.')


def main() -> None:
    rospy.init_node('mpc_controller_node')
    MPCControllerNode()
    rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
