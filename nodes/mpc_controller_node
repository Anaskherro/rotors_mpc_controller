#!/usr/bin/env python3

"""ROS front-end for the acados-based NMPC controller."""

from __future__ import annotations

import math
import threading
from typing import Optional

import numpy as np
import rospy
from dynamic_reconfigure.server import Server
from geometry_msgs.msg import PoseStamped
from mav_msgs.msg import Actuators
from nav_msgs.msg import Odometry

from rotors_mpc_controller import (PositionNMPC, ReferenceGenerator,
                                   apply_dynamic_configuration,
                                   load_params)
from rotors_mpc_controller.cfg import RotorsMPCConfig



def quaternion_to_euler(qx: float, qy: float, qz: float, qw: float) -> tuple[float, float, float]:
    norm = math.sqrt(qx * qx + qy * qy + qz * qz + qw * qw)
    if norm == 0.0:
        return 0.0, 0.0, 0.0
    qx /= norm
    qy /= norm
    qz /= norm
    qw /= norm

    sinr_cosp = 2.0 * (qw * qx + qy * qz)
    cosr_cosp = 1.0 - 2.0 * (qx * qx + qy * qy)
    roll = math.atan2(sinr_cosp, cosr_cosp)

    sinp = 2.0 * (qw * qy - qz * qx)
    pitch = math.copysign(math.pi / 2.0, sinp) if abs(sinp) >= 1.0 else math.asin(sinp)

    siny_cosp = 2.0 * (qw * qz + qx * qy)
    cosy_cosp = 1.0 - 2.0 * (qy * qy + qz * qz)
    yaw = math.atan2(siny_cosp, cosy_cosp)
    return roll, pitch, yaw


class MPCControllerNode:
    def __init__(self) -> None:
        self._params = load_params()
        self._controller = PositionNMPC(self._params)
        self._reference = ReferenceGenerator(self._params['reference'])
        self._reference.update_hover_thrust(self._controller.hover_thrust)
        self._topics = dict(self._params['topics'])
        node_cfg = self._params.get('node', {})
        self._rate_hz = float(node_cfg.get('rate', 50.0))
        self._log_interval = float(node_cfg.get('log_interval', 3.0))
        self._last_log_time = rospy.Time.now()
        self._controller_lock = threading.Lock()

        self._rotor_force_constant = self._controller.rotor_force_constant
        self._motor_min_speed, self._motor_max_speed = self._controller.motor_speed_limits

        self._state: Optional[dict] = None
        self._last_command = np.full(4, self._controller.hover_thrust, dtype=float)

        self._motor_pub = rospy.Publisher(self._topics['motor'], Actuators, queue_size=1)
        self._state_sub = rospy.Subscriber(self._topics['state'], Odometry,
                                           self._odom_cb, queue_size=1)
        self._reference_topic = self._topics.get('reference', '~setpoint')
        self._reference_sub = rospy.Subscriber(self._reference_topic, PoseStamped,
                                               self._reference_cb, queue_size=1)

        self._timer = rospy.Timer(rospy.Duration(1.0 / self._rate_hz), self._loop)
        self._reconfig_srv = Server(RotorsMPCConfig, self._reconfigure_cb)
        rospy.loginfo('mpc_controller_node: ready (dt=%.3f, horizon=%d)',
                      self._controller.dt, self._controller.horizon)

    def _reference_cb(self, msg: PoseStamped) -> None:
        position = np.array([msg.pose.position.x,
                             msg.pose.position.y,
                             msg.pose.position.z], dtype=float)
        yaw = self._yaw_from_quaternion(msg.pose.orientation.x,
                                        msg.pose.orientation.y,
                                        msg.pose.orientation.z,
                                        msg.pose.orientation.w)
        self._reference.set_target(position=position, yaw=yaw)

    def _odom_cb(self, msg: Odometry) -> None:
        pose = msg.pose.pose
        twist = msg.twist.twist

        px, py, pz = pose.position.x, pose.position.y, pose.position.z
        vx_body = np.array([twist.linear.x, twist.linear.y, twist.linear.z], dtype=float)

        roll, pitch, yaw = quaternion_to_euler(pose.orientation.x,
                                               pose.orientation.y,
                                               pose.orientation.z,
                                               pose.orientation.w)

        rot = self._rotation_matrix(roll, pitch, yaw)
        velocity_world = rot @ vx_body

        quaternion = np.array([pose.orientation.w,
                                pose.orientation.x,
                                pose.orientation.y,
                                pose.orientation.z], dtype=float)

        self._state = {
            'position': np.array([px, py, pz], dtype=float),
            'velocity': velocity_world,
            'quaternion': quaternion,
            'body_rates': np.array([twist.angular.x, twist.angular.y, twist.angular.z], dtype=float),
        }

    def _loop(self, _: rospy.TimerEvent) -> None:
        if self._state is None:
            return

        reference = self._reference.build_horizon(self._controller.horizon,
                                                  self._controller.dt)

        with self._controller_lock:
            thrust_cmd, status = self._controller.solve(self._state, reference)
        if status != 0:
            rospy.logwarn_throttle(1.0, 'mpc_controller_node: solver returned status %d', status)
            if self._last_command is not None:
                self._publish_command(self._last_command)
                self._maybe_log(reference, thrust_cmd, status)
            return
        self._publish_command(thrust_cmd)
        self._maybe_log(reference, thrust_cmd, status)

    @staticmethod
    def _yaw_from_quaternion(qx: float, qy: float, qz: float, qw: float) -> float:
        _, _, yaw = quaternion_to_euler(qx, qy, qz, qw)
        return yaw

    @staticmethod
    def _rotation_matrix(roll: float, pitch: float, yaw: float) -> np.ndarray:
        cr = math.cos(roll)
        sr = math.sin(roll)
        cp = math.cos(pitch)
        sp = math.sin(pitch)
        cy = math.cos(yaw)
        sy = math.sin(yaw)
        return np.array([
            [cp * cy, cy * sp * sr - sy * cr, cy * sp * cr + sy * sr],
            [cp * sy, sy * sp * sr + cy * cr, sy * sp * cr - cy * sr],
            [-sp, cp * sr, cp * cr],
        ], dtype=float)

    def _publish_command(self, thrust: np.ndarray) -> None:
        lbu, ubu = self._controller.input_bounds
        clipped = np.clip(np.asarray(thrust, dtype=float), lbu, ubu)
        speeds_sq = clipped / max(self._rotor_force_constant, 1e-9)
        speeds_sq = np.clip(speeds_sq, 0.0, self._motor_max_speed ** 2)
        speeds = np.sqrt(speeds_sq)
        speeds = np.clip(speeds, self._motor_min_speed, self._motor_max_speed)

        msg = Actuators()
        msg.header.stamp = rospy.Time.now()
        msg.angular_velocities = speeds.tolist()
        self._motor_pub.publish(msg)
        self._last_command = clipped

    def _maybe_log(self, reference: dict, thrust_cmd: np.ndarray, status: int) -> None:
        now = rospy.Time.now()
        if (now - self._last_log_time).to_sec() < self._log_interval:
            return
        self._last_log_time = now

        ref_pos = reference['positions'][0]
        ref_vel = reference['velocities'][0]
        ref_quat = reference['quaternions'][0]
        ref_rates = reference['body_rates'][0]
        ref_thrust = reference['thrusts'][0] if reference['thrusts'].size else np.zeros(4)

        rospy.loginfo(
            'MPC log: status=%d pos=%s vel=%s quat=%s ref_pos=%s ref_vel=%s ref_quat=%s ref_rates=%s ref_thrust=%s cmd=%s',
            status,
            np.array2string(self._state['position'], precision=3),
            np.array2string(self._state['velocity'], precision=3),
            np.array2string(self._state['quaternion'], precision=3),
            np.array2string(ref_pos, precision=3),
            np.array2string(ref_vel, precision=3),
            np.array2string(ref_quat, precision=3),
            np.array2string(ref_rates, precision=3),
            np.array2string(ref_thrust, precision=3),
            np.array2string(thrust_cmd, precision=3),
        )

    def _reconfigure_cb(self, config: RotorsMPCConfig, level: int) -> RotorsMPCConfig:
        with self._controller_lock:
            topics_cfg, reference_defaults, node_meta = apply_dynamic_configuration(self._params, config)

            rospy.loginfo('mpc_controller_node: rebuilding ACADOS solver...')
            new_controller = PositionNMPC(self._params)
            self._controller = new_controller

            regen_dt = new_controller.dt
            regen_horizon = new_controller.horizon
            regen_codegen = getattr(new_controller, 'codegen_path', 'n/a')
            self._rotor_force_constant = new_controller.rotor_force_constant
            self._motor_min_speed, self._motor_max_speed = new_controller.motor_speed_limits
            self._reference.update_hover_thrust(new_controller.hover_thrust)
            self._log_interval = node_meta['log_interval']

            self._reference.update_defaults(reference_defaults['position'],
                                            reference_defaults['velocity'],
                                            reference_defaults['yaw'],
                                            frame=reference_defaults['frame'])

            if topics_cfg != self._topics:
                if self._state_sub is not None:
                    self._state_sub.unregister()
                if self._reference_sub is not None:
                    self._reference_sub.unregister()
                if self._motor_pub is not None:
                    self._motor_pub.unregister()
                self._topics = dict(topics_cfg)
                self._motor_pub = rospy.Publisher(self._topics['motor'], Actuators, queue_size=1)
                self._state_sub = rospy.Subscriber(self._topics['state'], Odometry,
                                                   self._odom_cb, queue_size=1)
                self._reference_topic = self._topics['reference']
                self._reference_sub = rospy.Subscriber(self._reference_topic, PoseStamped,
                                                       self._reference_cb, queue_size=1)

            new_rate = node_meta['rate']
            if new_rate > 0.0 and not math.isclose(new_rate, self._rate_hz):
                self._rate_hz = new_rate
                if hasattr(self, '_timer') and self._timer is not None:
                    self._timer.shutdown()
                self._timer = rospy.Timer(rospy.Duration(1.0 / self._rate_hz), self._loop)

        rospy.loginfo('mpc_controller_node: regenerated ACADOS model (dt=%.3f, horizon=%d, codegen=%s)',
                      regen_dt, regen_horizon, regen_codegen)

        config.solver_horizon_steps = self._params['solver']['horizon_steps']
        config.solver_dt = self._params['solver']['dt']
        config.solver_position_weight_x = self._params['solver']['position_weight'][0]
        config.solver_position_weight_y = self._params['solver']['position_weight'][1]
        config.solver_position_weight_z = self._params['solver']['position_weight'][2]
        config.solver_velocity_weight_x = self._params['solver']['velocity_weight'][0]
        config.solver_velocity_weight_y = self._params['solver']['velocity_weight'][1]
        config.solver_velocity_weight_z = self._params['solver']['velocity_weight'][2]
        config.solver_quat_weight_w = self._params['solver']['quaternion_weight'][0]
        config.solver_quat_weight_x = self._params['solver']['quaternion_weight'][1]
        config.solver_quat_weight_y = self._params['solver']['quaternion_weight'][2]
        config.solver_quat_weight_z = self._params['solver']['quaternion_weight'][3]
        config.solver_rate_weight_x = self._params['solver']['rate_weight'][0]
        config.solver_rate_weight_y = self._params['solver']['rate_weight'][1]
        config.solver_rate_weight_z = self._params['solver']['rate_weight'][2]
        config.solver_control_weight_f1 = self._params['solver']['control_weight'][0]
        config.solver_control_weight_f2 = self._params['solver']['control_weight'][1]
        config.solver_control_weight_f3 = self._params['solver']['control_weight'][2]
        config.solver_control_weight_f4 = self._params['solver']['control_weight'][3]
        config.solver_terminal_weight_px = self._params['solver']['terminal_weight'][0]
        config.solver_terminal_weight_py = self._params['solver']['terminal_weight'][1]
        config.solver_terminal_weight_pz = self._params['solver']['terminal_weight'][2]
        config.solver_terminal_weight_vx = self._params['solver']['terminal_weight'][3]
        config.solver_terminal_weight_vy = self._params['solver']['terminal_weight'][4]
        config.solver_terminal_weight_vz = self._params['solver']['terminal_weight'][5]
        config.solver_terminal_weight_qw = self._params['solver']['terminal_weight'][6]
        config.solver_terminal_weight_qx = self._params['solver']['terminal_weight'][7]
        config.solver_terminal_weight_qy = self._params['solver']['terminal_weight'][8]
        config.solver_terminal_weight_qz = self._params['solver']['terminal_weight'][9]
        config.solver_terminal_weight_wx = self._params['solver']['terminal_weight'][10]
        config.solver_terminal_weight_wy = self._params['solver']['terminal_weight'][11]
        config.solver_terminal_weight_wz = self._params['solver']['terminal_weight'][12]
        config.solver_regularization = self._params['solver']['regularization']
        if hasattr(config, 'solver_iter_max'):
            config.solver_iter_max = self._params['solver']['iter_max']
        config.solver_codegen_directory = self._params['solver'].get('codegen_directory', '')

        config.vehicle_mass = self._params['vehicle']['mass']
        inertia = self._params['vehicle']['inertia']
        config.vehicle_inertia_xx = inertia[0]
        config.vehicle_inertia_xy = inertia[1]
        config.vehicle_inertia_xz = inertia[2]
        config.vehicle_inertia_yx = inertia[3]
        config.vehicle_inertia_yy = inertia[4]
        config.vehicle_inertia_yz = inertia[5]
        config.vehicle_inertia_zx = inertia[6]
        config.vehicle_inertia_zy = inertia[7]
        config.vehicle_inertia_zz = inertia[8]
        config.vehicle_arm_length = self._params['vehicle']['arm_length']
        config.vehicle_rotor_force_constant = self._params['vehicle']['rotor_force_constant']
        config.vehicle_rotor_moment_constant = self._params['vehicle']['rotor_moment_constant']
        config.vehicle_motor_min_speed = self._params['vehicle']['motor_min_speed']
        config.vehicle_motor_max_speed = self._params['vehicle']['motor_max_speed']
        drag = self._params['vehicle']['drag_coefficients']
        config.vehicle_drag_x = drag[0]
        config.vehicle_drag_y = drag[1]
        config.vehicle_drag_z = drag[2]

        config.controller_thrust_min = self._params['controller']['thrust_limits'][0]
        config.controller_thrust_max = self._params['controller']['thrust_limits'][1]

        config.world_gravity = self._params['world']['gravity']

        config.reference_frame = self._params['reference']['frame']
        config.reference_position_x = self._params['reference']['default_position'][0]
        config.reference_position_y = self._params['reference']['default_position'][1]
        config.reference_position_z = self._params['reference']['default_position'][2]
        config.reference_velocity_x = self._params['reference']['default_velocity'][0]
        config.reference_velocity_y = self._params['reference']['default_velocity'][1]
        config.reference_velocity_z = self._params['reference']['default_velocity'][2]
        config.reference_acceleration_x = self._params['reference']['default_acceleration'][0]
        config.reference_acceleration_y = self._params['reference']['default_acceleration'][1]
        config.reference_acceleration_z = self._params['reference']['default_acceleration'][2]
        config.reference_yaw = self._params['reference']['default_yaw']

        config.topic_state = self._topics['state']
        config.topic_motor = self._topics['motor']
        config.topic_reference = self._topics['reference']

        node_cfg = self._params['node']
        config.node_rate = self._rate_hz
        config.node_log_interval = self._log_interval

        return config


def main() -> None:
    rospy.init_node('mpc_controller_node')
    MPCControllerNode()
    rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
