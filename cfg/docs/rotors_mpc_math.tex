\documentclass[11pt,a4paper]{article}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{bm}
\usepackage{geometry}
\geometry{margin=2.5cm}

% ---------------------------------------------------------------------------
\title{Mathematical Description of the \texttt{rotors\_mpc\_controller}}
\author{Generated by Codex}
\date{\today}

\begin{document}
\maketitle

\section{State and Control Definitions}

The nonlinear model predictive controller (NMPC) operates on a 13--state quadrotor model with four rotor thrust inputs. The state vector is
\begin{equation}
    \bm{x} = \begin{bmatrix}
        \bm{p} \\
        \bm{v} \\
        \bm{q} \\
        \bm{\omega}
    \end{bmatrix} 
    = \begin{bmatrix}
        x & y & z & v_x & v_y & v_z & q_w & q_x & q_y & q_z & \omega_x & \omega_y & \omega_z
    \end{bmatrix}^\top,
\end{equation}
where $\bm{p}$ is the position of the vehicle in the world frame, $\bm{v}$ is the linear velocity, $\bm{q}$ is the unit quaternion representing body orientation (scalar-first convention), and $\bm{\omega}$ are the body angular rates.

The control input is the vector of body-frame rotor thrusts
\begin{equation}
    \bm{u} = \begin{bmatrix} f_1 & f_2 & f_3 & f_4 \end{bmatrix}^\top,
\end{equation}
with $f_i \ge 0$ expressed in newtons.

\section{Rigid-Body Dynamics}

The translational dynamics follow from Newton's second law. Let $m$ denote the mass, $g$ the gravitational acceleration, and $R(\bm{q}) \in \mathbb{R}^{3\times3}$ the rotation matrix obtained from the quaternion. Summing the rotor thrusts produces the body-frame force
\begin{equation}
    \bm{F}_b = \begin{bmatrix} 0 & 0 & \sum_{i=1}^4 f_i \end{bmatrix}^\top.
\end{equation}
Transforming to the world frame and subtracting gravity yields the translational acceleration
\begin{equation}
    \dot{\bm{p}} = \bm{v}, \qquad
    \dot{\bm{v}} = \frac{1}{m} R(\bm{q})\,\bm{F}_b - \begin{bmatrix}0 & 0 & g \end{bmatrix}^\top.
\end{equation}

The quaternion kinematics are
\begin{equation}
    \dot{q}_w = -\frac{1}{2} (\bm{q}_v^\top \bm{\omega}), \qquad
    \dot{\bm{q}}_v = \frac{1}{2} \left( q_w \bm{\omega} + \bm{q}_v \times \bm{\omega} \right),
\end{equation}
with $\bm{q}_v = [q_x, q_y, q_z]^\top$ and $\times$ denoting the cross product. The implementation renormalises the quaternion before each solve to mitigate drift.

The torque generated by each rotor depends on its position relative to the vehicle centre and the aerodynamic drag constant. Let $\bm{r}_i = (x_i, y_i, 0)$ be the horizontal offset of rotor $i$ and $\tau_i$ its reaction torque about the body $z$-axis. For the enforced ``+'' geometry used by the controller,
\begin{align}
    \bm{r}_1 &= (\ell, 0, 0), & \tau_1 &= -c_m f_1, \\
    \bm{r}_2 &= (0, \ell, 0), & \tau_2 &= +c_m f_2, \\
    \bm{r}_3 &= (-\ell, 0, 0), & \tau_3 &= -c_m f_3, \\
    \bm{r}_4 &= (0, -\ell, 0), & \tau_4 &= +c_m f_4,
\end{align}
where $\ell$ is the arm length and $c_m$ the rotor moment constant.

The resulting body torques are
\begin{align}
    \tau_x &= \sum_{i=1}^4 y_i f_i, \\
    \tau_y &= -\sum_{i=1}^4 x_i f_i, \\
    \tau_z &= \sum_{i=1}^4 \tau_i.
\end{align}

Assuming a diagonal inertia matrix $J = \operatorname{diag}(J_x, J_y, J_z)$, the angular acceleration is
\begin{equation}
    \dot{\bm{\omega}} = J^{-1} \Big( \bm{\tau} - \bm{\omega} \times (J\bm{\omega}) \Big),
\end{equation}
with $\bm{\tau} = [\tau_x, \tau_y, \tau_z]^\top$.

Collecting the derivatives gives the continuous-time dynamics
\begin{equation}
    \dot{\bm{x}} = f(\bm{x}, \bm{u}) =
    \begin{bmatrix}
        \bm{v} \\
        \frac{1}{m} R(\bm{q})\,\bm{F}_b - \bm{g} \\
        \dot{\bm{q}} \\
        J^{-1} \Big( \bm{\tau} - \bm{\omega} \times (J\bm{\omega}) \Big)
    \end{bmatrix},
\end{equation}
where $\bm{g} = [0, 0, g]^\top$.

The equations are integrated in acados using an explicit Runge--Kutta (ERK) scheme with a fixed sample time $\Delta t$ (default $\SI{0.05}{s}$) and horizon $N=20$.

\section{Optimal Control Problem}

At each control step the NMPC solves the discrete-time optimal control problem
\begin{align}
    \min_{\{\bm{x}_k,\bm{u}_k\}}\; & \frac{1}{2} \sum_{k=0}^{N-1} \left\| \bm{y}_k - \bm{y}_k^{\text{ref}} \right\|_{W}^2 
    + \frac{1}{2} \left\| \bm{y}_N - \bm{y}_N^{\text{ref}} \right\|_{W_e}^2, \\
    \text{s.t.}\; & \bm{x}_0 = \hat{\bm{x}}_0, \\
    & \bm{x}_{k+1} = F(\bm{x}_k, \bm{u}_k), \qquad k = 0,\dots,N-1, \\
    & \bm{u}_{\min} \le \bm{u}_k \le \bm{u}_{\max}, \\
    & \bm{x}_{\min} \le \bm{x}_k \le \bm{x}_{\max},
\end{align}
where $F(\cdot)$ denotes the discrete-time dynamics obtained from the ERK integrator and $\hat{\bm{x}}_0$ is the measured state.

The linear least-squares output vector is defined as
\begin{equation}
    \bm{y}_k = \begin{bmatrix} \bm{p}_k \\ \bm{v}_k \\ \bm{q}_k \\ \bm{\omega}_k \\ \bm{u}_k \end{bmatrix},
\end{equation}
with block-diagonal weighting matrices
\begin{equation}
    W = \operatorname{diag}\big( W_p, W_v, W_q, W_\omega, W_u \big), \qquad
    W_e = \operatorname{diag}\big( W_{p,e}, W_{v,e}, W_{q,e}, W_{\omega,e} \big).
\end{equation}
The default diagonal entries are populated from the configuration file `config/params.yaml`. For example, the stage weights satisfy
\begin{align}
    W_p &= \operatorname{diag}(10, 10, 8), & W_v &= \operatorname{diag}(1, 1, 0.2), \\
    W_q &= \operatorname{diag}(3.2, 3.2, 3.2, 3.2), & W_\omega &= \operatorname{diag}(1.4, 1.4, 0.4), \\
    W_u &= \operatorname{diag}(1.75, 1.75, 1.75, 1.75),
\end{align}
while the terminal weights emphasise yaw alignment through $W_{q,e,zz} = 18.5$.

The reference trajectory $\{\bm{y}_k^{\text{ref}}\}$ is generated by `ReferenceGenerator`, which repeats the target pose, velocity, body rates, and rotor thrust along the horizon. In hover the reference is $(\bm{p}, \bm{v}, \bm{q}, \bm{\omega}, \bm{u}) = ((0,0,1), \bm{0}, (1,0,0,0), \bm{0}, \bm{u}_\text{hover})$ with $\bm{u}_\text{hover}$ equal to $mg/4$ per rotor.

\section{Constraints and Parameters}

Input bounds follow from motor speed limits:
\begin{equation}
    f_i^{\min} = c_f \, \omega_{i,\min}^2, \qquad
    f_i^{\max} = c_f \, \omega_{i,\max}^2,
\end{equation}
where $c_f$ is the rotor force constant. In the default configuration $f_i^{\min} = 0$ (after clamping negative values) and $f_i^{\max} \approx \SI{6.1}{N}$ for each rotor. The controller further clips the commanded thrust to user-provided limits $[4,20]$~N before converting them back to motor speeds.

State constraints are set to wide bounds ($\pm 10^6$) to avoid artificial clipping; only the initial state equality $\bm{x}_0 = \hat{\bm{x}}_0$ is enforced by acados.

The controller exposes all scalar parameters through ROS dynamic reconfigure (see `cfg/rotors_mpc.cfg`). Sliding a parameter in `rqt\_reconfigure` updates the solver configuration, regenerates the acados code if necessary, and continues the NMPC loop without restarting the node.

\section{ROS Node Architecture}

The executable `nodes/mpc_controller_node` bridges ROS and the NMPC:
\begin{itemize}
    \item Subscribes to `/hummingbird/ground_truth/odometry` to populate $\hat{\bm{x}}_0$.
    \item Subscribes to `/mpc_controller/setpoint` (\texttt{PoseStamped}) to update the position and yaw reference.
    \item Publishes actuator commands on `/hummingbird/command/motor_speed` after mapping thrust commands to rotor angular velocities via
    \begin{equation}
        \omega_i = \sqrt{ \tfrac{f_i}{c_f} }.
    \end{equation}
    \item Optionally logs solver status, current state, and reference every `node.log_interval` seconds.
\end{itemize}

All parameters listed at the beginning of the prompt arise directly from `config/params.yaml` and mirror the defaults used in this document.

\section{Summary}

The \texttt{rotors\_mpc\_controller} implements a Gauss--Newton NMPC scheme with linear least-squares costs, explicit Runge--Kutta integration, and actuator saturation for a quadrotor flying the RotorS Hummingbird model. This document summarises the mathematical foundations to facilitate further analysis or tuning.

\end{document}
